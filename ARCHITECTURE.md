# Architecture

This codebase is set up as a [Cargo workspace](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html). The `rover` binary is built from the root `bin` target, which is a thin wrapper around the `rover-client` library crate.

## CLI Design

Great thought and attention has been paid to Rover's design, and any new command surface must be considered holistically.

### Command layout

Rover commands are laid out as `rover [NOUN] [VERB]` to create clear separation of concerns for multiple areas of graph management.

### Designing new commands

Generally, we are hesitant to add a new `NOUN` to Rover's surface area, unless there is a clear and real need. 

An example of a clear need is the `graph` vs. `subgraph` vs. `supergraph` command structure. Each of these nouns has similar associated verbs. 

Let's look at the `fetch` commands as an example. `rover graph fetch` and `rover subgraph fetch` each take a positional required `<GRAPH_REF>` argument, and `subgraph fetch` also has a required `--subgraph` flag. It really looks like there doesn't need to be differentiation between these commands. We could have made this behavior implicit by making `--subgraph` optional, and only returning a subgraph schema if the `--subgraph` argument was provided. 

The problem with this approach is that having two different return types from the same command leads to unexpected results and makes it difficult to understand the mental model needed to work with the graph registry. Additionally, it would have made it difficult to design commands that _only_ exist for `subgraphs`, and vice versa (such as `rover subgraph check`).

In general, it is best to keep related commands together, and to avoid cognitive complexity wherever possible. New commands should either be associated with an existing top-level noun, or a new noun should be proposed.

### Project Structure

- `Cargo.toml`: crate metadata, including definitions for both internal and external dependencies

- `Cargo.lock`: an autogenerated lockfile for Rover's dependencies

- `src`: the `rover` CLI
    - `src/bin/rover.rs`: the entry point for the CLI executable
    - `src/command`: logic for the CLI commands
      - `src/command/output.rs`: Enum containing all possible `stdout` options for Rover commands
      - `src/command/{command_name}/mod.rs`: Contains the definition of Rov
    - `src/utils`: shared utility functions
    - `src/error`: application-level error handling including suggestions and error codes
    - `src/cli.rs`: Module containing definition for all top-level commands
    - `src/lib.rs`: all the logic used by the CLI

- `tests`: Integration tests

- `crates`
    - `crates/houston`: logic related to configuring rover
    - `crates/robot-panic`: Fork of `human-panic` to create panic handlers that allows users to submit crash reports as GitHub issues
    - `crates/rover-client`: logic for querying apollo services
    - `crates/sputnik`: logic for capturing anonymous usage data
    - `crates/timber`: output formatting and logging logic
    - `crates/xtask`: logic for building and testing Rover

- `.cargo`: Sets up `cargo xtask` commands in the workspace

- `docs`
    - `source/*.md`: Individual documentation pages
    - `source/assets`: Images and other resources
    - `static/_redirects`: [Netlify redirects](https://docs.netlify.com/routing/redirects/)

- `netlify.toml`: Configuration for Rover's [docs](https://apollographql.com/docs/rover)

- `installers`
    - `binstall`: Rover's cross-platform installer that downloads and installs prebuilt binaries
    - `npm`: Rover's npm installer that downloads and installs prebuilt binaries

- `.github`
    - `ISSUE_TEMPLATE`: Issues templates for our GitHub repository
    - `workflows/lint.yml`: GitHub Action that checks for idiomatic code style, proper formatting, and broken markdown links
    - `workflows/release.yml`: GitHub Action that builds cross-platform binaries and creates a GitHub release when a version is tagged
    - `workflows/test.yml`: Runs integration and unit tests on each commit that is pushed to GitHub

### Guide to adding a new command

Prior to adding a new command to Rover, you should familiarize yourself with Rover's existing [architecture](./ARCHITECTURE.md) and to make sure that you have discussed the design of the new command in a [GitHub issue](#Using-issues) before submitting a pull request.

#### `rover graph hello`

Let's walk through what it would look like to add a new `hello` subcommand to the `rover graph` command namespace.

##### Scaffold the new command

The first thing we want to do when creating a new command is to create an entry point for it. The current project does not have a `graph hello` command as you can see here:

```console
$ cargo run -- graph hello
    Finished dev [unoptimized + debuginfo] target(s) in 0.09s
     Running `target/debug/rover graph hello`
error: The subcommand 'hello' wasn't recognized
        Did you mean 'help'?

If you believe you received this message in error, try re-running with 'rover graph -- hello'

USAGE:
    rover graph [OPTIONS] <SUBCOMMAND>

For more information try --help
```

---

Each of Rover's "nouns" has their own module in `src/command`. The noun we are trying to add a verb command to is `graph`. If you open `src/command/graph/mod.rs`, you can see an example of how each of the `graph` commands are laid out. 

Each one has their own file, and is included with a `mod command;` statement at the top of the file. The entry for `rover graph publish` and its help text are laid out in `mod.rs` in a struct with the `StructOpt` trait automatically derived. (You can read more about StructOpt [here](https://docs.rs/structopt/latest/structopt/)).

The actual logic for `rover graph publish` lives in `src/command/graph/publish.rs`

Before we can add the command to Rover's API, allowing us to run it, we need to define the command and its possible arguments, along with providing a simple `run` function. We can do this under the `src/command` directory.

Subcommands each have their own files or directories under `src/command`. Files directly in `src/command` are flat commands with no subcommands, like `rover info` in `src/command/info.rs`. Commands with subcommands include files for each of their subcommands, like `rover graph publish` in `src/command/graph/publish.rs`. Here, each argument is laid out in the `Publish` struct, and a `run` method is added to the struct. 

A minimal command in Rover would be laid out exactly like this:

```rust
#[derive(Debug, Serialize, StructOpt)]
pub struct MyNewCommand { }

impl MyNewCommand {
  pub fn run(&self) -> Result<RoverStdout> {
    Ok(RoverStdout::None)
  }
}
```

For our `graph hello` command, we'll add a new `hello.rs` file under `src/command/graph` with the following contents: 

```rust
use serde::Serialize;
use structopt::StructOpt;

use crate::command::RoverStdout;
use crate::Result;

#[derive(Debug, Serialize, StructOpt)]
pub struct Hello { }

impl Hello {
    pub fn run(&self) -> Result<RoverStdout> {
        eprintln!("Hello, world!");
        Ok(RoverStdout::None)
    }
}
```

In this file, the `pub struct Hello` struct declaration is where we define the arguments and options available for our `Hello` command.

In its current state, this file would not be compiled, as the module is not included in the parent module.

To fix this, we will include the newly created `hello` module in `src/command/graph/mod.rs`:

```rust
mod hello;
```

Then, we can add a `Hello` value to the `Command` enum like so:

```rust
#[derive(Debug, Serialize, StructOpt)]
pub enum Command {
  ...
  /// Say hello to a graph!
  Hello(hello::Hello),
}
```

`hello::Hello`, the value associated with the `Hello` variant of `Command`, is the struct that we created in the previous step. The doc comment here `/// Say hello to a graph` is also important, as that's the description for the command that will be shown when running `rover graph --help`.

Running `cargo check` or an editor extension (like Rust Analyzer for VS Code) will warn you that `pattern &Hello not covered` for the `impl` block below the enum definition. This just means that for the `run` function in the `mod.rs` file we're in, we're not matching all possible variants of the `Command` enum. 

Add the following line to the `match` block. This tells StructOpt that when we encounter the `graph hello` command, we want to use the `Hello::run` function that we defined earlier to execute it:

```
Command::Hello(command) => command.run(),
```

After adding that, there should be no errors when running `cargo check` and we can run our basic command using `cargo run`:

```shell
$ cargo run -- graph hello
  Finished dev [unoptimized + debuginfo] target(s) in 0.08s
  Running `target/debug/rover graph hello`
Hello, world!
```

##### Accepting required arguments and optional flags

Rover uses a library called [StructOpt](https://docs.rs/structopt) to build commands. We apply the `StructOpt` trait using the `#[derive(StructOpt)]` syntax above it, to let `StructOpt` know that this is a command definition, and the values and implementations for this struct will be related to the command defined by `Hello`.

All commands under the `graph` namespace accept a required, positional argument `<GRAPH_REF>` that describes the graph and variant a user is operating on. Additionally, it takes an optional `--profile` flag that can swap out the API token a user is using to interact with the graph registry.

In order to add these to our new `graph hello` command, we should copy and paste the field from any other `graph` command like so:

```rust
#[derive(Debug, Serialize, StructOpt)]
pub struct Hello {
    /// <NAME>@<VARIANT> of graph in Apollo Studio to publish to.
    /// @<VARIANT> may be left off, defaulting to @current
    #[structopt(name = "GRAPH_REF", parse(try_from_str = parse_graph_ref))]
    #[serde(skip_serializing)]
    graph: GraphRef

    /// Name of configuration profile to use
    #[structopt(long = "profile", default_value = "default")]
    #[serde(skip_serializing)]
    profile_name: String,
}
```

We'll have to also add some import statements at the top of our file to support parsing this new argument:

```rust
use crate::utils::parsers::{parse_graph_ref, GraphRef};
```

Now, if we run the command again, it will complain if we don't provide a graph ref:

```console
$ cargo run -- graph hello
     Running `target/debug/rover graph hello`
error: The following required arguments were not provided:
    <GRAPH_REF>

USAGE:
    rover graph hello [OPTIONS] <GRAPH_REF>

For more information try --help
```

##### Setting up a command to work with `rover-client`

Most of Rover's commands make requests to Apollo Studio's API. Rather than handling the request logic in the main package in the repository, Rover is structured so that logic lives in `crates/rover-client`. This is helpful for separation of concerns and testing.

In order to access functionality from `rover-client` in our `rover graph hello` command, we'll need to pass down a client from the entry to our command in `src/command/graph/mod.rs`. 

You can do this by changing the `Command::Hello(command) => command.run(),` line to `Command::Hello(command) => command.run(client_config),`.

Then you'll need to change `Hello::run` to accept a `client_config: StudioClientConfig` parameter in `src/command/graph/hello.rs`, and add a `use crate::utils::client::StudioClientConfig` import statement. Then, at the top of the run function, you can create a `StudioClient` by adding `let client = client_config.get_client(&self.profile_name)?;`. You can see examples of this in the other commands.

##### Auto-generated help command

Now that we've successfully scaffolded out a new `rover graph hello` command that is ready to start making requests to the Apollo Studio API, we can take a look at the help command.

```console
$ cargo run -- graph hello --help
rover-graph-hello 0.1.5
Hello, World!

USAGE:
    rover graph hello [OPTIONS] <GRAPH_REF>

FLAGS:
    -h, --help    Prints help information

OPTIONS:
    -l, --log <log-level>           Specify Rover's log level [possible values: error, warn, info,
                                    debug, trace]
        --profile <profile-name>    Name of configuration profile to use [default: default]

ARGS:
    <GRAPH_REF>    <NAME>@<VARIANT> of graph in Apollo Studio to publish to. @<VARIANT> may be left off, defaulting
                   to @current
```

`<GRAPH_REF>` and `--profile <profile-name>` should look familiar to you, but `-h, --help`, and `-l --log <log-level>` might seem a bit magical.

The `--help` flag is automatically created by `StructOpt`, and the `--log` flag is defined as a global flag in `src/cli.rs` on the top level `Rover` struct.

##### Important note on telemetry

Any time you are creating a new command, you need to make sure to add `#[serde(skip_serializing)]` to any flag or parameter that could contain personally identifiable information (PII), as commands and their parameters without this attribute are automatically sent to our telemetry endpoint.

##### Adding a query to Apollo Studio

The only piece of the `rover-client` crate that we need to be concerned with for now is the `src/query` directory. This is where all the queries to Apollo Studio live. This directory is roughly organized by the command names as well, but there may be some queries in these directories that are used by multiple commands.

You can see in the `src/query/graph` directory a number of `.rs` files paired with `.graphql` files. The `.graphql` files are the files where the GraphQL operations live, and the matching `.rs` files contain the logic needed to execute those operations.

##### Writing a GraphQL operation

For our basic `graph hello` command, we're going to make a request for a specific graph to Apollo Studio, inquiring about the existence of a graph, and nothing else. For this, we can use the `Query.service` field.

Create a `hello.graphql` file in `crates/rover-client/src/query/graph` and paste the following into it:

```graphql
query GraphHello($graphId: ID!) {
  service(id: $graphId) {
    deletedAt
  }
}
```

This simple GraphQL operation uses a graph's unique ID (which we get from the `GraphRef` we defined earlier), and fetches the graph from the registry, along with a field describing when it was deleted. Using this information, we can determine if a graph exists (if the `service` field is `null`) and if it was deleted and no longer usable.

Note: It can be very helpful to use the Studio Explorer to navigate the Apollo Studio API when creating new queries. This can be found [here](https://studio-staging.apollographql.com/graph/engine/explorer?variant=prod), but is not open to the public at this time.

##### Writing the request handler

This project uses [graphql-client](https://docs.rs/graphql_client/latest/graphql_client/) to generate types for each raw `.graphql` query that we write.

You'll want to create an empty file at `crates/rover-client/src/query/graph/hello.rs`.

In order to start compiling this file, we need to export the module in `crates/rover-client/src/query/graph/mod.rs`:

```rust
...
/// "Graph hello" command execution
pub mod hello;
```

Back in `hello.rs`, we'll import the following types:

```rust
use crate::blocking::StudioClient;
use crate::RoverClientError;
use graphql_client::*;
```

Then, we'll create a new struct that will have auto-generated types for the `hello.graphql` file that we created earlier:

```rust
#[derive(GraphQLQuery)]
// The paths are relative to the directory where your `Cargo.toml` is located.
// Both json and the GraphQL schema language are supported as sources for the schema
#[graphql(
    query_path = "src/query/graph/hello.graphql",
    schema_path = ".schema/schema.graphql",
    response_derives = "PartialEq, Debug, Serialize, Deserialize",
    deprecated = "warn"
)]
/// This struct is used to generate the module containing `Variables` and
/// `ResponseData` structs.
pub struct GraphHello;
```

Since the type we will be returning is autogenerated to be a `Timestamp`, we'll need to add the following line:

```
type Timestamp = String;
```

From here, we'll want an entrypoint to actually run the query. To do so, we'll create a public `run` function:

```rust
pub fn run(
    variables: graph_hello::Variables,
    client: &StudioClient,
) -> Result<Timestamp, RoverClientError> {
    Ok("stub".to_string())
}
```

Before we go any further, lets make sure everything is set up properly. We're going back to `src/command/graph/hello.rs` to add a call to our newly created `run` function.

It should look something like this (you should make sure you are following the style of other commands when creating new ones):

```rust
pub fn run(&self, client_config: StudioClientConfig) -> Result<RoverStdout> {
    let client = client_config.get_client(&self.profile_name)?;
    let graph_ref = self.graph.to_string();
    eprintln!(
        "Checking deletion of graph {} using credentials from the {} profile.",
        Cyan.normal().paint(&graph_ref),
        Yellow.normal().paint(&self.profile_name)
    );
    let deleted_at = hello::run(
        hello::graph_hello::Variables {
            graph_id: self.graph.name.clone(),
        },
        &client,
    )?;
    Ok(RoverStdout::PlainText(deleted_at))
}
```

Since we've just stubbed out a fake response without actually executing the query, this command should just print out `stub` every time you run it with a valid graph ref.

To actually execute the query, we'll modify our `rover-client` hello.rs to look like this:

```rust
pub fn run(
    variables: graph_hello::Variables,
    client: &StudioClient,
) -> Result<Timestamp, RoverClientError> {
    let graph = variables.graph_id.clone();
    let data = client.post::<GraphHello>(variables)?;
    build_response(data, graph)
}

fn build_response(
    data: graph_hello::ResponseData,
    graph: String,
) -> Result<Timestamp, RoverClientError> {
    let service = data.service.ok_or(RoverClientError::NoService { graph })?;
    service.deleted_at.ok_or(RoverClientError::AdhocError {
        msg: "Graph has never been deleted".to_string(),
    })
}
```

This should get you to the point where you can run `rover graph hello <GRAPH_REF>` and see if and when the last graph was deleted. From here, you should be able to follow the examples of other commands to write out tests for the `build_response` function. This is left as an exercise for the reader.

##### `RoverStdout`

Now that you can actually execute the `hello::run` query and return its result, you should create a new variant of `RoverStdout` in `src/command/output.rs` that is not `PlainText`. Your new variant should print the descriptor using the `print_descriptor` function, and print the raw content using `print_content`.

You'll want to change the line `Ok(RoverStdout::PlainText(deleted_at))` to `Ok(RoverStdout::DeletedAt(deleted_at))`, add a new `DeletedAt(String)` variant to `RoverStdout`, and then match on it in `pub fn print(&self)`:

```rust
...
RoverStdout::DeletedAt(timestamp) => {
    print_descriptor("Deleted At");
    print_content(&timestamp);
}
```

##### Error handling

Rover places a very strong emphasis on good error handling, with properly structured errors, accompanying error codes, and actionable suggestions to resolve errors. Each workspace crate uses `thiserror` to create a top level error enum in `error.rs` that defines all of the possible errors that can occur in that crate. 

Then, in Rover, we create a `RoverError` struct defined in `src/error/mod.rs` that formats each of these errors, and adds some extra metadata to them for end users. Each time a new error is added to any workspace crate, you'll receive a compiler error complaining about an unmatched variant in `src/error/metadata/mod.rs`. This new error type should then be mapped to either an existing variant of the `Suggestion` enum (`src/error/metadata/suggestion.rs`), or a new one should be created. Additionally, a new error code should likely be created in `code.rs`, along with a longer form description of that error code in a markdown file in `src/error/codes`. 

##### Environment Variables

Most environment variables within Rover are preceded with `APOLLO_`. In order to support a new environment variable following this format, you'll want to head to `src/utils/env.rs`, and add a new variant to the enum there. It should be as easy as following the patterns set out there and passing the variable where you need it to go. The top level `Rover` struct has a global `RoverEnv` instance that will slurp up all of the system's environment variables into a `HashMap` that can then be accessed in any command. `RoverEnv` also provides the ability to mock specific environment variables for use in testing.
