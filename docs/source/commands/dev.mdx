---
title: The Rover dev command
description: Run your supergraph in your local dev environment
---

A _supergraph_ is an architecture consisting of multiple GraphQL APIs (_subgraphs_) and a _graph router_ that runs in front of them:

```mermaid
graph LR;
  clients(Clients);
  subgraph "Supergraph";
  router(["Graph Router"]);
  serviceA[Subgraph A];
  serviceB[Subgraph B];
  router --- serviceA & serviceB;
  end;
  clients -.- router;
  class clients secondary;
```

While you're making local changes to an individual subgraph, you can use the `rover dev` command to start a local router instance and test out the effects of those changes on your entire supergraph.

<Caution>

Don't run `rover dev` in production. It's for local development only.

</Caution>

Whenever you add, modify, or remove a subgraph from your local supergraph, Rover automatically re-composes your individual subgraph schemas into a unified supergraph schema, which your local router session automatically begins using.

## Starting a router session

**To use `rover dev`, you need at least one running GraphQL API (subgraph).** Rover can obtain a subgraph's schema via introspection (either standard or [federated introspection](/federation/subgraph-spec#enhanced-introspection-with-query_service)), or you can provide a local schema file.

Here's an example `rover dev` command that points to a locally running subgraph and provides its schema via a local file:

```bash title="Example command"
rover dev --name products --schema ./products.graphql --url http://localhost:4000
```

<Note>

You don't have to provide a locally running subgraph. You can point to any GraphQL endpoint that your local environment can reach. You can even mix and match local and remote subgraphs, which is helpful for testing local changes against your staging subgraphs.

</Note>

When you start your first `rover dev` process:

1. Rover obtains the subgraph schema you provide (via either introspection or file path).
2. Rover composes a [supergraph schema](/federation/federated-types/overview/#supergraph-schema) from the subgraph schema.
3. Rover starts a locally running [router](/router) session and provides it the supergraph schema.
4. Rover starts watching the provided subgraph schema for changes (via either introspection or file), and it recomposes the supergraph schema whenever it detects a change. This automatically reloads the router.

After you start a local router session with your first `rover dev` process, you can run additional `rover dev` processes to [add subgraphs to the session.](#adding-a-subgraph-to-a-session)

### Starting a session with multiple subgraphs

If you have a standard set of subgraphs that you're always developing with, you can create a [supergraph config file](./supergraphs#yaml-configuration-file) to add all of them to your local router session with a single `rover dev` command.

For example, this `supergraph.yaml` file provides the necessary details for two subgraphs:

```yaml title="supergraph.yaml"
federation_version: =2.4.7
subgraphs:
  products:
    routing_url: http://localhost:4000
    schema:
      file: ./products.graphql # Schema provided via file
  reviews:
    schema:
      subgraph_url: http://localhost:4001 # Schema provided via introspection, routing_url can be omitted
  users:
    # routing_url: <Optional, pulled from GraphOS registry by default>
    schema:  # Schema downloaded from GraphOS registry, does not poll for updates
      graphref: mygraph@current
      subgraph: actors
```

You provide this file to `rover dev` like so:

```bash
rover dev --supergraph-config supergraph.yaml
```

If you do, a router session starts with one of the subgraphs listed, then adds the remaining subgraphs one at a time (order is undefined). Because of this, you might observe composition errors during intermediate steps.

Providing a `supergraph.yaml` file also enables you to take advantage of [other config options](./supergraphs#yaml-configuration-file), such as `introspection_headers`.

If you start your session with a config file, you can still [add other subgraphs individually](#adding-a-subgraph-to-a-session). However, you can't provide another config file.

## Adding a subgraph to a session

After you start a router session with your first `rover dev` command, you can then add other subgraphs to that same session.

To add a subgraph, open a new terminal window and run `rover dev` again, this time providing the details of the subgraph to add. For example, this command adds a `users` subgraph:

```bash
rover dev --name users --url http://localhost:4002
```

Rover detects your existing session and attaches this new process to it.

When you add a new subgraph to a session, Rover recomposes the supergraph schema and updates the router so you can query all added subgraphs via the single router endpoint.

<Note>

Rover uses the port of the running router to identify an existing session. If you specify a custom port via `--supergraph-port` or `--router-config`, make sure to specify the same port for all `rover dev` processes that you want to attach to the same session.

</Note>

## Stopping a session

If you stop your initial `rover dev` process (by pressing `CTRL+C`), it shuts down the local router session. This also shuts down any secondary `rover dev` processes attached to that same session.

## Removing a subgraph

If you stop a secondary `rover dev` process (by pressing `CTRL+C`), its associated router session recomposes its supergraph schema without the corresponding subgraph and reloads the router.

## Health check

By default, the router's health check endpoint is disabled in `rover dev`. You can enable it again by enabling it in a router configuration YAML file and passing it to `rover dev` via the `--router-config` argument described in the following section.

## Configuring the router

To configure advanced router functionality like CORS settings or header passthrough for subgraphs, you can pass a valid [router configuration YAML file](/router/configuration/overview#yaml-config-file) to `rover dev` via the `--router-config <ROUTER_CONFIG_PATH>` argument.

Note that only the main `rover dev` process uses this router configuration file when starting the router. If you specify a different listen address with `supergraph.listen`, all other `rover dev` processes need to pass the same values to `--supergraph-port` and `--supergraph-address`, and/or pass the same router configuration file path via `--router-config`.

### Enterprise features

If you want to use [enterprise router features](/router/enterprise-features/), you must provide both:

1. A graph ref via the `APOLLO_GRAPH_REF` environment variable.
2. A [**graph** API key](/graphos/api-keys/#graph-api-keys) either via the `APOLLO_KEY` environment or by [configuring credentials](./config#creating-configuration-profiles) in Rover.

## Federation 2 ELv2 license

The first time you use Federation 2 composition on a particular machine, Rover prompts you to accept the terms and conditions of the [ELv2 license](/resources/elastic-license-v2-faq/). On future invocations, Rover remembers that you already accepted the license and doesn't prompt you again (even if you update Rover).

The ELv2-licensed plugins, `supergraph` (built from [this source](https://github.com/apollographql/federation-rs)) and `router` (built from [this source](https://github.com/apollographql/router)) are installed to `~/.rover/bin` if you installed with the `curl | sh` installer, and to `./node_modules/.bin/` if you installed with npm.

## Versioning

By default, `rover dev` uses a recent version of the router and composition to use for you. This is currently configured in the Rover GitHub repo, however, you can override these by setting the environment variables `APOLLO_ROVER_DEV_COMPOSITION_VERSION=2.0.0` and/or `APOLLO_ROVER_DEV_ROUTER_VERSION=1.0.0`. By default, `rover dev` will always use a composition library with a major version of v2, and a router with a major version of v1. If you already have the plugins installed, you can pass `--skip-update` to `rover dev` in order to keep the plugins at the same version.
